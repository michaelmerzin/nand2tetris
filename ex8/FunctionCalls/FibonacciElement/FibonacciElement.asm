///////  write bootstrap_code
@256
D=A;
@SP
M=D;
///////  write call Sys.init 0
///////  write save_caller_frame
@.bootstrap$ret.0
D=A;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@LCL
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@ARG
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THIS
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THAT
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write set_arg for 0
@SP
A=M;
D=A;
@5
D=D-A;
@address
M=D;
@address
D=M;
@ARG
M=D;
@SP
D=M;
@LCL
M=D;
@Sys.init
0;JMP
(.bootstrap$ret.0)
///////  write function Main.fibonacci 0
(Main.fibonacci)
///////  write set_local_segment for 0
@SP
D=M;
@LCL
M=D;
// push argument 0
@ARG
A=M;
D=A;
@0
D=D+A;
@address
M=D;
@address
A=M;
D=M;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
// push constant 2
@2
D=A;
@SP
A=M;
M=D;
@SP
M=M+1;
// lt  ///////////////////////
@SP
M=M-1;
@SP
A=M;
D=M;
@y
M=D;
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M;
@y
D=D-M;
@GOOD0
D;JLT
(BAD0)
D=0;
@PUSH0
0;JMP
(GOOD0)
D=-1;
(PUSH0)
@SP
A=M;
M=D;
@SP
M=M+1;
//////// write if  //
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M
@Main.Main.fibonacci$IF_TRUE
D;JNE
//////// write goto  //
@Main.Main.fibonacci$IF_FALSE
0;JMP
//////// write label  //
(Main.Main.fibonacci$IF_TRUE)
// push argument 0
@ARG
A=M;
D=A;
@0
D=D+A;
@address
M=D;
@address
A=M;
D=M;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write return
///////  write frame = LCL
@LCL
D=M;
@frame
M=D;
///////  write return_address = *(frame-5)
@frame
D=M;
@5
D=D-A;
A=D;
D=M;
@retAddress
M=D;
///////  write *ARG = pop()
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M;
@ARG
A=M;
M=D;
///////  write SP = ARG + 1
@ARG
D=M;
@SP
M=D;
@SP
M=M+1;
///////  write restore frame
///////  write restore that
@frame
D=M;
@1
D=D-A;
A=D;
D=M;
@THAT
M=D;
///////  write restore this
@frame
D=M;
@2
D=D-A;
A=D;
D=M;
@THIS
M=D;
///////  write restore arg
@frame
D=M;
@3
D=D-A;
A=D;
D=M;
@ARG
M=D;
///////  write restore lcl
@frame
D=M;
@4
D=D-A;
A=D;
D=M;
@LCL
M=D;
@retAddress
A=M;
0;JMP
//////// write label  //
(Main.Main.fibonacci$IF_FALSE)
// push argument 0
@ARG
A=M;
D=A;
@0
D=D+A;
@address
M=D;
@address
A=M;
D=M;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
// push constant 2
@2
D=A;
@SP
A=M;
M=D;
@SP
M=M+1;
// sub ///////////////////////
@SP
M=M-1;
@SP
A=M;
D=M;
@y
M=D;
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M;
@y
D=D-M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write call Main.fibonacci 1
///////  write save_caller_frame
@Main.Main.fibonacci$ret.0
D=A;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@LCL
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@ARG
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THIS
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THAT
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write set_arg for 1
@SP
A=M;
D=A;
@6
D=D-A;
@address
M=D;
@address
D=M;
@ARG
M=D;
@SP
D=M;
@LCL
M=D;
@Main.fibonacci
0;JMP
(Main.Main.fibonacci$ret.0)
// push argument 0
@ARG
A=M;
D=A;
@0
D=D+A;
@address
M=D;
@address
A=M;
D=M;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
// push constant 1
@1
D=A;
@SP
A=M;
M=D;
@SP
M=M+1;
// sub ///////////////////////
@SP
M=M-1;
@SP
A=M;
D=M;
@y
M=D;
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M;
@y
D=D-M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write call Main.fibonacci 1
///////  write save_caller_frame
@Main.Main.fibonacci$ret.1
D=A;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@LCL
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@ARG
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THIS
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THAT
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write set_arg for 1
@SP
A=M;
D=A;
@6
D=D-A;
@address
M=D;
@address
D=M;
@ARG
M=D;
@SP
D=M;
@LCL
M=D;
@Main.fibonacci
0;JMP
(Main.Main.fibonacci$ret.1)
// add ///////////////////////
@SP
M=M-1;
@SP
A=M;
D=M;
@y
M=D;
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M;
@y
D=D+M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write return
///////  write frame = LCL
@LCL
D=M;
@frame
M=D;
///////  write return_address = *(frame-5)
@frame
D=M;
@5
D=D-A;
A=D;
D=M;
@retAddress
M=D;
///////  write *ARG = pop()
@SP
M=M-1;
@SP
A=M;
D=M;
@x
M=D;
@x
D=M;
@ARG
A=M;
M=D;
///////  write SP = ARG + 1
@ARG
D=M;
@SP
M=D;
@SP
M=M+1;
///////  write restore frame
///////  write restore that
@frame
D=M;
@1
D=D-A;
A=D;
D=M;
@THAT
M=D;
///////  write restore this
@frame
D=M;
@2
D=D-A;
A=D;
D=M;
@THIS
M=D;
///////  write restore arg
@frame
D=M;
@3
D=D-A;
A=D;
D=M;
@ARG
M=D;
///////  write restore lcl
@frame
D=M;
@4
D=D-A;
A=D;
D=M;
@LCL
M=D;
@retAddress
A=M;
0;JMP
///////  write function Sys.init 0
(Sys.init)
///////  write set_local_segment for 0
@SP
D=M;
@LCL
M=D;
// push constant 4
@4
D=A;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write call Main.fibonacci 1
///////  write save_caller_frame
@Sys.Sys.init$ret.0
D=A;
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@LCL
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@ARG
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THIS
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
@THAT
D=M
@address_value
M=D;
@address_value
D=M;
@SP
A=M;
M=D;
@SP
M=M+1;
///////  write set_arg for 1
@SP
A=M;
D=A;
@6
D=D-A;
@address
M=D;
@address
D=M;
@ARG
M=D;
@SP
D=M;
@LCL
M=D;
@Main.fibonacci
0;JMP
(Sys.Sys.init$ret.0)
//////// write label  //
(Sys.Sys.init$WHILE)
//////// write goto  //
@Sys.Sys.init$WHILE
0;JMP
